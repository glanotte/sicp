(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
(define (my-filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (my-filter predicate (cdr sequence))))
        (else (my-filter predicate (cdr sequence)))))
(define (multiple-dwelling)
  (define (valid? baker cooper fletcher miller smith)
    (and (distinct? (list baker cooper fletcher miller smith))
         (not (= baker 5))
         (not (= cooper 1))
         (not (= fletcher 5))
         (not (= fletcher 1))
         (> miller cooper)
         (not (= (abs (- smith fletcher)) 1))
         (not (= (abs (- fletcher cooper)) 1))))
  (define (flat-map proc lst)
    (if (null? lst)
      '()
      (let ((first (proc (car lst))))
        ((if (pair? first) append cons)
         first
         (flat-map proc (cdr lst))))))

  (define (permutations lst)
    (if (null? lst)
      (list '())
      (flat-map
        (lambda (first)
          (map
            (lambda (rest) (cons first rest))
            (permutations (my-filter (lambda (x) (not (= x first))) lst))))
        lst)))
  (my-filter
    (lambda (x) (apply valid? x))
    (permutations (list 1 2 3 4 5))))

